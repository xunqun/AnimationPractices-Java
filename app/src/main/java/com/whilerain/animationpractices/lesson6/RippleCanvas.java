package com.whilerain.animationpractices.lesson6;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.os.CountDownTimer;import androidx.annotation.Nullable;import android.util.AttributeSet;import android.view.View;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class RippleCanvas extends View {    private Paint paint = new Paint();    private int drawLeft, drawTop, drawWidth, drawHeight;    private List<RippleAnimator> ripples = new ArrayList<>();    public RippleCanvas(Context context) {        super(context);        initView();    }    public RippleCanvas(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        initView();    }    public RippleCanvas(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        initView();    }    private void initView() {        paint.setStyle(Paint.Style.STROKE);        paint.setColor(Color.WHITE);        paint.setStrokeWidth(2);    }    @Override    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {        super.onLayout(changed, left, top, right, bottom);        drawLeft = 0 + getPaddingLeft();        drawTop = 0 + getPaddingTop();        drawWidth = right - left - getPaddingRight() - getPaddingLeft();        drawHeight = bottom - top - getPaddingTop() - getPaddingBottom();    }    @Override    protected void onDraw(Canvas canvas) {        drawAllRipples(canvas);        super.onDraw(canvas);    }    public void createRipple() {        RippleAnimator r = new RippleAnimator(4000);        ripples.add(r);        r.start();    }    private void drawAllRipples(Canvas canvas) {        Iterator<RippleAnimator> iterator = ripples.iterator();        while (iterator.hasNext()) {            RippleAnimator r = iterator.next();            if (r.isFinished) {                iterator.remove();            } else {                if (canvas != null) r.draw(canvas);            }        }    }    class RippleAnimator extends CountDownTimer {        private final long duration;        private Float ratio = 0f;        private int tickCounter = 0;        public boolean isFinished = false;        public RippleAnimator(long duration) {            super(duration, 30);            this.duration = duration;        }        @Override        public void onTick(long millisUntilFinished) {            tickCounter++;            ratio = ((float) duration - millisUntilFinished) / duration;            invalidate();        }        @Override        public void onFinish() {            isFinished = true;        }        public void draw(Canvas canvas) {            int x = drawWidth / 2 + drawLeft;            int y = drawHeight / 2 + drawTop;            float radius = (drawWidth) * ratio;            paint.setAlpha((int) ((1 - ratio) * 255));            canvas.drawOval(x - radius, y - radius, x + radius, y + radius, paint);        }    }}